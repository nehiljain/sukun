# Architecture

This document provides an overview of gestral's codebase and deployment architecture.

## Codebase

```
├── .github/                    # CI/CD workflows and configurations
├── app/                        # Main Django application
│   ├── core/                   # Core utilities - exceptions, decorators.
│   ├── common/                # Shared utilities and common components
│   ├── email/                 # Email application
│   ├── user_auth/              # User and organization management
│   └── your_app/             # Video generation functionality
├── client/                   # Frontend pages
├── db_scripts/                # Database scripts
├── infra/                     # Terraform infrastructure as code
├── Makefile                  # Build automation scripts
├── pyproject.toml            # Python project configuration
└── README.md                 # Project README
```


## Deployed Architecture

The application is deployed using a containerized architecture with the following components:

1. **Web Application Server**: A container/VM running the app Docker image generated by CI/CD pipelines
2. **Celery Workers**: One or more containers/VMs running the same Docker image but with a different entry point for background task processing
3. **Database**: A dedicated database server (managed separately)
4. **Load Balancer**: Distributes traffic between application instances (managed separately)
5. **Object Storage**: For storing static files and media (managed separately)

```mermaid
graph TD
    %% Styling
    classDef loadBalancer fill:#4CAF50,stroke:#2E7D32,stroke-width:2px,color:#fff;
    classDef webApp fill:#2196F3,stroke:#1565C0,stroke-width:2px,color:#fff;
    classDef database fill:#FF9800,stroke:#EF6C00,stroke-width:2px,color:#fff;
    classDef messageQueue fill:#E91E63,stroke:#C2185B,stroke-width:2px,color:#fff;
    classDef celeryWorker fill:#9C27B0,stroke:#6A1B9A,stroke-width:2px,color:#fff;
    classDef objectStorage fill:#009688,stroke:#00695C,stroke-width:2px,color:#fff;

    %% Nodes
    LB[Load Balancer\nDistributes HTTP/HTTPS]:::loadBalancer
    WEB1[Web App Container 1\nHandles Requests]:::webApp
    WEB2[Web App Container 2\nHandles Requests]:::webApp
    DB[(Database\nSQL/NoSQL)]:::database
    MQ[(Message Queue\nTask Queuing)]:::messageQueue
    CW1[Celery Worker 1\nTask Processing]:::celeryWorker
    CW2[Celery Worker 2\nTask Processing]:::celeryWorker
    S3[(Object Storage\nStatic Files)]:::objectStorage

    %% Edges with labels
    LB -->|HTTP/HTTPS| WEB1
    LB -->|HTTP/HTTPS| WEB2
    WEB1 -->|Database Queries| DB
    WEB2 -->|Database Queries| DB
    WEB1 -->|Task Queuing| MQ
    WEB2 -->|Task Queuing| MQ
    MQ -->|Task Processing| CW1
    MQ -->|Task Processing| CW2
    CW1 -->|Data Storage| DB
    CW2 -->|Data Storage| DB
    WEB1 -->|Static Files| S3
    WEB2 -->|Static Files| S3

    %% Layout adjustments
    subgraph Frontend
        LB
        WEB1
        WEB2
    end
    subgraph Backend
        DB
        MQ
        CW1
        CW2
    end
    subgraph Storage
        S3
    end

```

### Deployment Components Explained

- **Web Application Containers**: Run the main Django application, serving HTTP requests for the SPA frontend
- **Celery Worker Containers**: Process background tasks like blog checking, video generation, and email sending
- **Database**: PostgreSQL database for storing application data (not managed by this codebase)
- **Message Queue**: Redis or RabbitMQ for queuing background tasks (not detailed in this diagram)
- **Object Storage**: S3-compatible storage for static files and media (not managed by this codebase)
- **Load Balancer**: Distributes incoming traffic across multiple web application instances (not managed by this codebase)
